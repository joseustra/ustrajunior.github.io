<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Let&#39;s code</title>
    <link>https://ustrajunior.com/</link>
    <description>Recent content on Let&#39;s code</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 12 Sep 2018 10:20:33 +0000</lastBuildDate>
    
	<atom:link href="https://ustrajunior.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Starting a New Ambitious Project</title>
      <link>https://ustrajunior.com/blog/starting-a-new-ambitious-project/</link>
      <pubDate>Wed, 12 Sep 2018 10:20:33 +0000</pubDate>
      
      <guid>https://ustrajunior.com/blog/starting-a-new-ambitious-project/</guid>
      <description>For a very short time, I used the Spacemacs emacs distribution. It&amp;rsquo;s very nice, but I ended up backing to vim and eventually, I moved to VS Code. Code editors away, when I was using Spacemacs, I found the Magit git client.
 Magit is an interface to the version control system Git, implemented as an Emacs package. Magit aspires to be a complete Git porcelain. While we cannot (yet) claim that Magit wraps and improves upon each and every Git command, it is complete enough to allow even experienced Git users to perform almost all of their daily version control tasks directly from within Emacs.</description>
    </item>
    
    <item>
      <title>json: unmarshal custom date formats</title>
      <link>https://ustrajunior.com/blog/json-unmarshal-custom-date-formats/</link>
      <pubDate>Thu, 03 Nov 2016 19:40:18 +0000</pubDate>
      
      <guid>https://ustrajunior.com/blog/json-unmarshal-custom-date-formats/</guid>
      <description>When we are building a JSON API, many times we have to deal with dates that we can&amp;rsquo;t have control of the layout.
Let&amp;rsquo;s see a common example using a format that Go knows by default.
type Checkin struct { Timestamp time.Time `json:&amp;quot;timestamp&amp;quot;` User string `json:&amp;quot;user&amp;quot;` } func main() { j := `{&amp;quot;timestamp&amp;quot;:&amp;quot;2016-11-02T08:18:20Z&amp;quot;, &amp;quot;user&amp;quot;:&amp;quot;John Doe&amp;quot;}` var c Checkin // error handling omitted for simplicity (don&#39;t do this). json.Unmarshal([]byte(j), &amp;amp;c) fmt.Println(c) }  Run on Playground.</description>
    </item>
    
    <item>
      <title>Variadic functions in Go</title>
      <link>https://ustrajunior.com/blog/variadic-functions-in-go/</link>
      <pubDate>Fri, 21 Oct 2016 18:55:08 +0000</pubDate>
      
      <guid>https://ustrajunior.com/blog/variadic-functions-in-go/</guid>
      <description>Let&amp;rsquo;s create a function that we can pass 3 numbers as arguments and them it returns the average of this numbers.
func average(num1, num2, num3 float64) float64 { avg := (num1 + num2 + num3) / 3 return avg }  and then, you call it like this
func main() { fmt.Println(average(2, 4, 6)) }  Le&amp;rsquo;ts run to see if works
$ go run average.go 4  It works. Super easy, but not so useful.</description>
    </item>
    
    <item>
      <title>Novos finders no rails 4</title>
      <link>https://ustrajunior.com/blog/novos-finders-no-rails-4/</link>
      <pubDate>Tue, 17 Dec 2013 11:07:51 +0000</pubDate>
      
      <guid>https://ustrajunior.com/blog/novos-finders-no-rails-4/</guid>
      <description>Com a entrada do Rails 4 alguns métodos mudaram. O métodos &amp;ldquo;mágicos&amp;rdquo; que a gente conhecia como find_all_by_name foram marcados como deprecated e serão removidos no Rails 4.1. Vamos ver alguns exemplos:
# Ao invés de usar os finders dinâmicos, agora usamos o where. Rails 3: Person.find_all_by_first_name(&#39;John&#39;) Rails 4: Person.where(first_name: &#39;John&#39;) # apartir dai utilizamos podemos utilizar algumas métodos para filtrar mais # First e Last Person.where(first_name: &#39;John&#39;).first Person.where(first_name: &#39;John&#39;).last Find, create, initialize Person.</description>
    </item>
    
    <item>
      <title>Quick tip - Retornando mais de um valor em um método</title>
      <link>https://ustrajunior.com/blog/retornando-mais-de-um-valor-em-um-metodo/</link>
      <pubDate>Thu, 27 Jun 2013 10:52:18 +0000</pubDate>
      
      <guid>https://ustrajunior.com/blog/retornando-mais-de-um-valor-em-um-metodo/</guid>
      <description>O comportamento padrão de um método Ruby, é retornar o último valor que ele possui. Então se tivermos o seguinte código:
def calc(x, y) a = x + y b = x - y c = x * y d = x / y end  Não importa quantas variáveis você tenha definido, o retorno sempre será a última, no caso d
calc(10, 5) =&amp;gt; 2  Mas, em algum momento podemos precisar que esse método retorne mais de um valor.</description>
    </item>
    
    <item>
      <title>Quick tip - Exclusão condicional em um Hash</title>
      <link>https://ustrajunior.com/blog/quick-tip-exclusao-condicional-em-um-hash/</link>
      <pubDate>Sun, 16 Jun 2013 10:28:41 +0000</pubDate>
      
      <guid>https://ustrajunior.com/blog/quick-tip-exclusao-condicional-em-um-hash/</guid>
      <description>Se você tem um hash e precisa remover algo dele, tem um função bem simples para esse serviço. O delete_if é um método onde você pode passar um block e fazer sua validação para decidir quais elementos irá remover.
# Supondo um Hash de cores com red, green e blue colors = { red: &#39;#FF0000&#39;, green: &#39;#008000&#39;, blue: &#39;#0000FF&#39; } # Mas eu não quero mais o red, então eu uso o **delete_if** colors.</description>
    </item>
    
    <item>
      <title>Formulário de contato sem banco de dados com ActiveAttr</title>
      <link>https://ustrajunior.com/blog/formulario-de-contato-sem-banco-de-dados-com-activeattr/</link>
      <pubDate>Fri, 14 Jun 2013 19:20:00 +0000</pubDate>
      
      <guid>https://ustrajunior.com/blog/formulario-de-contato-sem-banco-de-dados-com-activeattr/</guid>
      <description>As vezes precisamos criar um formulário de contato que simplesmente envie a mensagem por email mas não mantenha o registro no sistema. Quando se usa Rails, o fluxo normal é após o formulário ser submetido, a informação é salva no banco porque usamos ActiveRecord.
Para que possamos submeter um formulário e não salvar no banco mas mesmo assim ter as facilidades que o AR fornece, iremos usar o ActiveAttr. Essa gem permite que tenhamos validações no nosso model e usemos o attr_accessible por exemplo.</description>
    </item>
    
    <item>
      <title>#100DaysOfCode</title>
      <link>https://ustrajunior.com/100daysofcode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ustrajunior.com/100daysofcode/</guid>
      <description></description>
    </item>
    
    <item>
      <title>About me</title>
      <link>https://ustrajunior.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ustrajunior.com/about/</guid>
      <description>I am a software developer, with 10+ years of experience working with technologies like Java, Ruby, Go (golang), Javascript, HTML, CSS, SQL Server, MySQL, MongoDB, AWS among others
Throughout my career, I was part of teams of various sizes and participated in the development of software of the most varied types, such as e-commerce sites, financial control systems, among others.
Currently, I work on a software called SuperWifi, created by Nextbit (where I&amp;rsquo;m a co-founder), that provides an intelligent connection between customers and vendors.</description>
    </item>
    
  </channel>
</rss>