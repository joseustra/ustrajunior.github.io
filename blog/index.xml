<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Code With Me</title>
    <link>https://ustrajunior.com/blog/index.xml</link>
    <description>Recent content in Blogs on Code With Me</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>José Carlos Ustra Júnior</copyright>
    <lastBuildDate>Thu, 03 Nov 2016 19:40:18 -0300</lastBuildDate>
    <atom:link href="https://ustrajunior.com/blog/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>json: unmarshal custom date formats</title>
      <link>https://ustrajunior.com/blog/json-unmarshal-custom-date-formats/</link>
      <pubDate>Thu, 03 Nov 2016 19:40:18 -0300</pubDate>
      
      <guid>https://ustrajunior.com/blog/json-unmarshal-custom-date-formats/</guid>
      <description>&lt;p&gt;When we are building a JSON API, many times we have to deal with dates that we can&amp;rsquo;t have control of the layout.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see a common example using a format that Go knows by default.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Checkin struct {
    Timestamp time.Time `json:&amp;quot;timestamp&amp;quot;`
    User      string    `json:&amp;quot;user&amp;quot;`
}

func main() {
    j := `{&amp;quot;timestamp&amp;quot;:&amp;quot;2016-11-02T08:18:20Z&amp;quot;, &amp;quot;user&amp;quot;:&amp;quot;John Doe&amp;quot;}`

    var c Checkin
    // error handling omitted for simplicity (don&#39;t do this).
    json.Unmarshal([]byte(j), &amp;amp;c)

    fmt.Println(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/XVooaZGomG&#34;&gt;Run on Playground&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here, we are using the RFC3339 format, so Go will do the correct unmarshal and fill the Timestamp field on the struct.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say, now, that we are consuming this information from a web service that uses a different date format.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
    // using / to divide the date and space for the time
    j := `{&amp;quot;timestamp&amp;quot;:&amp;quot;2016/11/02 08:18:20&amp;quot;, &amp;quot;user&amp;quot;:&amp;quot;John Doe&amp;quot;}`

    var c Checkin
    err := json.Unmarshal([]byte(j), &amp;amp;c)
    if err != nil {
        fmt.Println(err)
    }

    fmt.Println(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this code we will see this error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;parsing time &amp;quot;&amp;quot;2016/11/02 08:18:20&amp;quot;&amp;quot; as &amp;quot;&amp;quot;2006-01-02T15:04:05Z07:00&amp;quot;&amp;quot;: cannot parse &amp;quot;/11/02 08:18:20&amp;quot;&amp;quot; as &amp;quot;-&amp;quot; {0001-01-01 00:00:00 +0000 UTC }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because Go doesn&amp;rsquo;t know how to handle this custom date format, so let&amp;rsquo;s write a custom date type to handle this special case.&lt;/p&gt;

&lt;p&gt;The first thing to do is create a custom type for the date, for example, &lt;strong&gt;SpecialDate&lt;/strong&gt;. This new type needs to implement the &lt;a href=&#34;https://golang.org/pkg/encoding/json/#Unmarshaler&#34;&gt;Unmarshaler interface&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type SpecialDate struct {
    time.Time
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, to implement the Unmarshaler interface, we need a function &lt;strong&gt;UnmarshalJSON&lt;/strong&gt; on the &lt;strong&gt;SpecialDate&lt;/strong&gt; type.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (sd *SpecialDate) UnmarshalJSON(input []byte) error {
    strInput := string(input)
    strInput = strings.Trim(strInput, `&amp;quot;`)
    newTime, err := time.Parse(&amp;quot;2006/01/02 15:04:05&amp;quot;, strInput)
    if err != nil {
        return err
    }

    sd.Time = newTime
    return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First, we get the input that is a []byte and convert it to string, then we remove the excedent double quotes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;strInput := string(input)
strInput = strings.Trim(strInput, `&amp;quot;`)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, we do the parse using the layout for our case.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;newTime, err := time.Parse(&amp;quot;2006/01/02 15:04:05&amp;quot;, strInput)
if err != nil {
    return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An explanation about the date layout. Normally, date layouts are used as yyyy/mm/dd but Go uses a real date and time to do the layout.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;year   == 2006
month  == 01
day    == 02
hour   == 15
minute == 04
second == 05
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, our case became &lt;strong&gt;2006/01/02 15:04:05&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;To finish our implementation, we need set the newTime to the SpecialDate and return nil because we don&amp;rsquo;t have errors.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;sd.Time = newTime
return nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With our new type implemented, we can now change the &lt;strong&gt;Checkin&lt;/strong&gt; struct to use the new SpecialDate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Checkin struct {
    Timestamp SpecialDate `json:&amp;quot;timestamp&amp;quot;`
    User      string      `json:&amp;quot;user&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The rest will be the same, check the full code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
    &amp;quot;encoding/json&amp;quot;
    &amp;quot;fmt&amp;quot;
    &amp;quot;strings&amp;quot;
    &amp;quot;time&amp;quot;
)

type Checkin struct {
    Timestamp SpecialDate `json:&amp;quot;timestamp&amp;quot;`
    User      string      `json:&amp;quot;user&amp;quot;`
}

type SpecialDate struct {
    time.Time
}

func (sd *SpecialDate) UnmarshalJSON(input []byte) error {
    strInput := string(input)
    strInput = strings.Trim(strInput, `&amp;quot;`)
    newTime, err := time.Parse(&amp;quot;2006/01/02 15:04:05&amp;quot;, strInput)
    if err != nil {
        return err
    }

    sd.Time = newTime
    return nil
}

func main() {
    j := `{&amp;quot;timestamp&amp;quot;:&amp;quot;2016/11/02 08:18:20&amp;quot;, &amp;quot;user&amp;quot;:&amp;quot;John Doe&amp;quot;}`

    var c Checkin
    err := json.Unmarshal([]byte(j), &amp;amp;c)
    if err != nil {
        fmt.Println(err)
    }

    fmt.Println(c)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://play.golang.org/p/-nZY-oupPX&#34;&gt;Run on Playground&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I hope this help you with custom dates when working with JSON.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Variadic functions in Go</title>
      <link>https://ustrajunior.com/blog/variadic-functions-in-go/</link>
      <pubDate>Fri, 21 Oct 2016 18:55:08 -0300</pubDate>
      
      <guid>https://ustrajunior.com/blog/variadic-functions-in-go/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s create a function that we can pass 3 numbers as arguments and them it returns the average of this numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func average(num1, num2, num3 float64) float64 {
	avg := (num1 + num2 + num3) / 3

	return avg
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then, you call it like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	fmt.Println(average(2, 4, 6))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Le&amp;rsquo;ts run to see if works&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ go run average.go
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It works. Super easy, but not so useful. Normally, when you want to calculate the average, you don&amp;rsquo;t know how many arguments you will need to accept. How can we handle this?&lt;/p&gt;

&lt;p&gt;When you have a function that you can&amp;rsquo;t determinate the number of arguments you are going to pass then you need a Variadic function.&lt;/p&gt;

&lt;p&gt;So, to do this, we just need use &amp;lsquo;&amp;hellip;&amp;rsquo; before the parameter type on the function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func average(numbers ...float64) float64 {
 // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But now, we don&amp;rsquo;t have separated values anymore, the &lt;em&gt;&amp;hellip;float64&lt;/em&gt; will be transformed in a slice of float64 and we need to iterate over the items to calculate the average.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func average(numbers ...float64) float64 {
	var total float64
	for _, num := range numbers {
		total += num
	}

	return total / float64(len(numbers))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a Variadic function in Go and we can pass as many arguments we want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	fmt.Println(average(2, 4, 6, 9, 5, 3, 12))
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Novos finders no rails 4</title>
      <link>https://ustrajunior.com/blog/novos-finders-no-rails-4/</link>
      <pubDate>Tue, 17 Dec 2013 11:07:51 -0300</pubDate>
      
      <guid>https://ustrajunior.com/blog/novos-finders-no-rails-4/</guid>
      <description>&lt;p&gt;Com a entrada do Rails 4 alguns métodos mudaram. O métodos &amp;ldquo;mágicos&amp;rdquo; que a gente conhecia como &lt;code&gt;find_all_by_name&lt;/code&gt; foram marcados como deprecated e serão removidos no Rails 4.1. Vamos ver alguns exemplos:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Ao invés de usar os finders dinâmicos, agora usamos o where.

Rails 3: Person.find_all_by_first_name(&#39;John&#39;)
Rails 4: Person.where(first_name: &#39;John&#39;)

# apartir dai utilizamos podemos utilizar algumas métodos para filtrar mais
# First e Last
Person.where(first_name: &#39;John&#39;).first
Person.where(first_name: &#39;John&#39;).last

Find, create, initialize
Person.where(first_name: &#39;John&#39;).first_or_create
Person.where(first_name: &#39;John&#39;).first_or_create!
Person.where(first_name: &#39;John&#39;).first_or_initialize
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outros dois métodos que foram introduzidos no Rails 4 e ajudam bastante são o find_by e find_by!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;Person.find_by(name: &#39;John&#39;)
Person.find_by!(name: &#39;John&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esses métodos são equivalentes a fazer &lt;code&gt;Person.where(name: &#39;John&#39;).first&lt;/code&gt; mas é uma forma mais limpa de escrever. A diferênca de usar a ! é que se ele não achar nada irá retornar um erro &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick tip - Retornando mais de um valor em um método</title>
      <link>https://ustrajunior.com/blog/retornando-mais-de-um-valor-em-um-metodo/</link>
      <pubDate>Thu, 27 Jun 2013 10:52:18 -0300</pubDate>
      
      <guid>https://ustrajunior.com/blog/retornando-mais-de-um-valor-em-um-metodo/</guid>
      <description>&lt;p&gt;O comportamento padrão de um método Ruby, é retornar o último valor que ele possui. Então se tivermos o seguinte código:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def calc(x, y)
    a = x + y
    b = x - y
    c = x * y
    d = x / y
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Não importa quantas variáveis você tenha definido, o retorno sempre será a última, no caso &lt;strong&gt;d&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;calc(10, 5)
=&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Mas, em algum momento podemos precisar que esse método retorne mais de um valor. Por exemplo, estamos precisando do valor de &lt;strong&gt;a&lt;/strong&gt; e &lt;strong&gt;b&lt;/strong&gt;. Como podemos retornar ao mesmo tempo? É muito simples na verdade. Basta fazer o método retornar um array com os valores que desejamos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;  def calc(x, y)
    a = x + y
    b = x - y
    c = x * y
    d = x / y
    [a,b]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;E para colocar cada valor em uma variável, basta fazer o seguinte:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;a, b = calc(10,5)
=&amp;gt; [15, 5]

a
=&amp;gt; 15

b
=&amp;gt; 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Eu sei que o exemplo não foi grande coisa, mas acho que deu pra pegar a ideia.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quick tip - Exclusão condicional em um Hash</title>
      <link>https://ustrajunior.com/blog/quick-tip-exclusao-condicional-em-um-hash/</link>
      <pubDate>Sun, 16 Jun 2013 10:28:41 -0300</pubDate>
      
      <guid>https://ustrajunior.com/blog/quick-tip-exclusao-condicional-em-um-hash/</guid>
      <description>&lt;p&gt;Se você tem um hash e precisa remover algo dele, tem um função bem simples para esse serviço. O &lt;strong&gt;delete_if&lt;/strong&gt; é um
método onde você pode passar um block e fazer sua validação para decidir quais elementos irá remover.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Supondo um Hash de cores com red, green e blue
colors = { red: &#39;#FF0000&#39;, green: &#39;#008000&#39;, blue: &#39;#0000FF&#39; }

# Mas eu não quero mais o red, então eu uso o **delete_if**
colors.delete_if{ |key, value| key == :red }
=&amp;gt; {:green=&amp;gt;&amp;quot;#008000&amp;quot;, :blue=&amp;gt;&amp;quot;#0000FF&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Simples assim.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Formulário de contato sem banco de dados com ActiveAttr</title>
      <link>https://ustrajunior.com/blog/formulario-de-contato-sem-banco-de-dados-com-activeattr/</link>
      <pubDate>Fri, 14 Jun 2013 19:20:00 -0300</pubDate>
      
      <guid>https://ustrajunior.com/blog/formulario-de-contato-sem-banco-de-dados-com-activeattr/</guid>
      <description>&lt;p&gt;As vezes precisamos criar um formulário de contato que simplesmente envie a mensagem por email mas não mantenha o registro no sistema.
Quando se usa Rails, o fluxo normal é após o formulário ser submetido, a informação é salva no banco porque usamos ActiveRecord.&lt;/p&gt;

&lt;p&gt;Para que possamos submeter um formulário e não salvar no banco mas mesmo assim ter as facilidades que o AR fornece, iremos usar o
&lt;a href=&#34;https://github.com/cgriego/active_attr&#34;&gt;ActiveAttr&lt;/a&gt;. Essa gem permite que tenhamos validações no nosso model e usemos o
&lt;em&gt;attr_accessible&lt;/em&gt; por exemplo.&lt;/p&gt;

&lt;p&gt;Então vamos primeiramente criar nosso model e adicionar algumas validações.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#app/models/contact.rb
class Contact
  # Primeiro, vamos adicionar o ActiveAttr
  include ActiveAttr::Model

  # agora definimos os campos que queremos usar
  attribute :name
  attribute :email
  attribute :subject
  attribute :content

  # e da mesma forma que fazemos no AR, vamos dizer
  # quais atributos podem ser passados pelo form
  attr_accessible :name, :email, :subject, :content

  # também iremos adicionar algumas validações básicas
  validates_presence_of :name
  validates_presence_of :email
  validates_format_of :email,
    :with =&amp;gt; /^[-a-z0-9_+\.]+\@([-a-z0-9]+\.)+[a-z0-9]{2,4}$/i
  validates_presence_of :subject
  validates_presence_of :content
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Com o model definido, o resto é basicamente a mesma coisa que você faria com qualquer controller e views usando AR.
Vamos criar o controller que irá pegar os dados submetidos e passar para o Mailer para serem enviados por email.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# app/controllers/contacts_controller.rb
class ContactsController &amp;lt; ApplicationController
  def new
    @contact = Contact.new
  end

  def create
    @contact = Contact.new(params[:contact])
    # a única diferença do método create padrão do rails,
    # é que iremos enviar por email e não chamar o método save
    ContactMailer.support_mail(@contact).deliver
    redirect_to root_path, notice: &#39;Your message was sent&#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Agora precisamos criar a view que irá conter nosso formulário.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#app/views/contacts/new.html.erb
# eu gosto de usar [simple_form](https://github.com/plataformatec/simple_form)
&amp;lt;%= simple_form_for @contact do |f| %&amp;gt;
    &amp;lt;%= f.error_notification %&amp;gt;

    &amp;lt;%= f.input :name %&amp;gt;
    &amp;lt;%= f.input :email %&amp;gt;
    &amp;lt;%= f.input :subject %&amp;gt;
    &amp;lt;%= f.input :content %&amp;gt;

    &amp;lt;%= f.submit %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Estamos com nosso formulário praticamente pronto, precisamos apenas criar o mailer para enviar as informações de contato.
Nada demais aqui, apenas um mailer comum.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#app/mailers/contact_mailer.rb
class ContactMailer &amp;lt; ActionMailer::Base
  default from: &amp;quot;from@example.com&amp;quot;

  def contact_mail(contact)
    @contact = contact
    mail(to: &#39;contact@example.com&#39;, subject: @contact.subject)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A view do mailer também não tem nada demais, a mesma coisa que estamos acostumados a fazer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;#app/views/contact_mailer/contact_mailer.html.erb
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;New menssage from: &amp;lt;%= @contact.name %&amp;gt;&amp;lt;/h1&amp;gt;

    &amp;lt;h2&amp;gt;&amp;lt;%= @contact.subject %&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;%= @contact.content %&amp;gt;&amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Com isso, temos um formulário de contato que envia a mensagem diretamente para o seu email de contato.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>