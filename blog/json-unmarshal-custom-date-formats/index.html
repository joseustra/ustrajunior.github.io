<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> json: unmarshal custom date formats &middot; Let&#39;s code </title>


<link rel="stylesheet" href="https://ustrajunior.com/css/slim.css">
<link rel="stylesheet" href="https://ustrajunior.com/css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/ocean.min.css">

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="Let&#39;s code" />

</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="https://ustrajunior.com/">Let&#39;s code</a></h1>
  <p class="site-tagline"></p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
      
      <li><a href="/about/">About</a></li>
       
	  <li class="spacer">&ac;</li>

      <li><a href="https://github.com/ustrajunior">Github</a></li> 
      <li><a href="https://twitter.com/ustrajunior">Twitter</a></li> 
    </ul>
  </div>
</div>
    <div class="content">
      <div class="posts">
        <div class="post">
          <h2 class="post-title"><a href="https://ustrajunior.com/blog/json-unmarshal-custom-date-formats/">json: unmarshal custom date formats</a></h2>
          <span class="post-date">Nov 3, 2016 </span>
          <div class="post-content">
            <p>When we are building a JSON API, many times we have to deal with dates that we can&rsquo;t have control of the layout.</p>

<p>Let&rsquo;s see a common example using a format that Go knows by default.</p>

<pre><code class="language-go">type Checkin struct {
    Timestamp time.Time `json:&quot;timestamp&quot;`
    User      string    `json:&quot;user&quot;`
}

func main() {
    j := `{&quot;timestamp&quot;:&quot;2016-11-02T08:18:20Z&quot;, &quot;user&quot;:&quot;John Doe&quot;}`

    var c Checkin
    // error handling omitted for simplicity (don't do this).
    json.Unmarshal([]byte(j), &amp;c)

    fmt.Println(c)
}
</code></pre>

<p><a href="https://play.golang.org/p/XVooaZGomG">Run on Playground</a>.</p>

<p>Here, we are using the RFC3339 format, so Go will do the correct unmarshal and fill the Timestamp field on the struct.</p>

<p>Let&rsquo;s say, now, that we are consuming this information from a web service that uses a different date format.</p>

<pre><code class="language-go">func main() {
    // using / to divide the date and space for the time
    j := `{&quot;timestamp&quot;:&quot;2016/11/02 08:18:20&quot;, &quot;user&quot;:&quot;John Doe&quot;}`

    var c Checkin
    err := json.Unmarshal([]byte(j), &amp;c)
    if err != nil {
        fmt.Println(err)
    }

    fmt.Println(c)
}
</code></pre>

<p>When we run this code we will see this error:</p>

<pre><code>parsing time &quot;&quot;2016/11/02 08:18:20&quot;&quot; as &quot;&quot;2006-01-02T15:04:05Z07:00&quot;&quot;: cannot parse &quot;/11/02 08:18:20&quot;&quot; as &quot;-&quot; {0001-01-01 00:00:00 +0000 UTC }
</code></pre>

<p>This is because Go doesn&rsquo;t know how to handle this custom date format, so let&rsquo;s write a custom date type to handle this special case.</p>

<p>The first thing to do is create a custom type for the date, for example, <strong>SpecialDate</strong>. This new type needs to implement the <a href="https://golang.org/pkg/encoding/json/#Unmarshaler">Unmarshaler interface</a>.</p>

<pre><code class="language-go">type SpecialDate struct {
    time.Time
}
</code></pre>

<p>Now, to implement the Unmarshaler interface, we need a function <strong>UnmarshalJSON</strong> on the <strong>SpecialDate</strong> type.</p>

<pre><code class="language-go">func (sd *SpecialDate) UnmarshalJSON(input []byte) error {
    strInput := string(input)
    strInput = strings.Trim(strInput, `&quot;`)
    newTime, err := time.Parse(&quot;2006/01/02 15:04:05&quot;, strInput)
    if err != nil {
        return err
    }

    sd.Time = newTime
    return nil
}
</code></pre>

<p>First, we get the input that is a []byte and convert it to string, then we remove the excedent double quotes.</p>

<pre><code class="language-go">strInput := string(input)
strInput = strings.Trim(strInput, `&quot;`)
</code></pre>

<p>Second, we do the parse using the layout for our case.</p>

<pre><code class="language-go">newTime, err := time.Parse(&quot;2006/01/02 15:04:05&quot;, strInput)
if err != nil {
    return err
}
</code></pre>

<p>An explanation about the date layout. Normally, date layouts are used as yyyy/mm/dd but Go uses a real date and time to do the layout.</p>

<pre><code>year   == 2006
month  == 01
day    == 02
hour   == 15
minute == 04
second == 05
</code></pre>

<p>So, our case became <strong>2006/01/02 15:04:05</strong>.</p>

<p>To finish our implementation, we need set the newTime to the SpecialDate and return nil because we don&rsquo;t have errors.</p>

<pre><code class="language-go">sd.Time = newTime
return nil
</code></pre>

<p>With our new type implemented, we can now change the <strong>Checkin</strong> struct to use the new SpecialDate.</p>

<pre><code class="language-go">type Checkin struct {
    Timestamp SpecialDate `json:&quot;timestamp&quot;`
    User      string      `json:&quot;user&quot;`
}
</code></pre>

<p>The rest will be the same, check the full code.</p>

<pre><code class="language-go">package main

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;strings&quot;
    &quot;time&quot;
)

type Checkin struct {
    Timestamp SpecialDate `json:&quot;timestamp&quot;`
    User      string      `json:&quot;user&quot;`
}

type SpecialDate struct {
    time.Time
}

func (sd *SpecialDate) UnmarshalJSON(input []byte) error {
    strInput := string(input)
    strInput = strings.Trim(strInput, `&quot;`)
    newTime, err := time.Parse(&quot;2006/01/02 15:04:05&quot;, strInput)
    if err != nil {
        return err
    }

    sd.Time = newTime
    return nil
}

func main() {
    j := `{&quot;timestamp&quot;:&quot;2016/11/02 08:18:20&quot;, &quot;user&quot;:&quot;John Doe&quot;}`

    var c Checkin
    err := json.Unmarshal([]byte(j), &amp;c)
    if err != nil {
        fmt.Println(err)
    }

    fmt.Println(c)
}
</code></pre>

<p><a href="https://play.golang.org/p/-nZY-oupPX">Run on Playground</a>.</p>

<p>I hope this help you with custom dates when working with JSON.</p>

          </div>
        </div>
        <div class="pagination">
          <a class="btn previous " href="https://ustrajunior.com/blog/starting-a-new-ambitious-project/"> Prev</a>  
          <a class="btn next " href="https://ustrajunior.com/blog/variadic-functions-in-go/"> Next</a> 
        </div>
      </div>
    </div>
    
    <div class="footer">
  
  <p>Powered by <a href="https://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
  
</div>

  </div>
  <script src="https://ustrajunior.com/js/slim.js"></script>
  <script src="https://ustrajunior.com/js/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script>
  <script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-10118580-1', 'auto');
ga('send', 'pageview');

</script>

</body>

</html>
